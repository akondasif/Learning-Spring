Minimizing XML configuration using Annotations
----------------------------------------------

* Autowiring a step further by letting Spring figure out which classes should be configured as Spring beans, reducing the need for the <bean> element.

[Understand by code snippet - demo of @Autowired, @Qualifier, @Component, @PostConstruct, @PreDestroy] ()

[Understand by code snippet - demo of Spring's @Value and SpEL] ()


Spring Annotations Fundamentals (notes taken from Spring in Action book)
----------------------------------------------------------------------
* Just like the XML configuration, need a way to bootstrap the annotation scanner. Use "<context:annotation-config>" to turn on annotations wiring in spring container.
 
* Spring 3 supports a few different annotations for autowiring:
	
	- Spring’s own @Autowired annotation
		- Can use at constructor, method and property level
		- If there are no applicable beans or if multiple beans could be autowired, then @Autowired will run into some trouble
		- @Autowired(required=false) - Optional autowiring configuration will not throw NoSuchBeanDefinitionException, if wiring fails
		- @Qualifier - useful to qualify ambiguous dependencies by providing a way of switching @Autowired’s by-type autowiring into explicit by-name wiring
	
	- The @Inject annotation from JSR-330
		- Almost complete drop-in replacement for Spring’s @Autowired annotation
		- Just like @Autowired, @Inject can be used to autowire properties, methods, and constructors. 
		- Unlike @Autowired, @Inject doesn’t have a required attribute. Therefore, @Inject-annotated dependencies are expected to be fulfilled, failing with an exception if they’re not.
		- The Provider interface enables, among other things, lazy injection of bean references and injection of multiple instances of a bean.
		- @Named - to qualify @Injected properties, similar to Spring's @Qualifier annotation.
		- @Qualifier annotation in the javax.inject package - to create custom JSR-330 annotations.
	
	- Using expressions with annotation injection
		- @Value - a new wiring annotation that lets you wire primitive values such as int, boolean, and String using annotations
			@Value("#{systemProperties.myFavoriteSong}")
			private String song;
	
	- The @Resource annotation from JSR-250 
		- Spring supports JSR-250 based annotations which include @Resource, @PostConstruct and @PreDestroy annotations

* Automatic bean discovery: 

	- <context:component-scan base-package="com.abc"> 
		- This element does everything that <context:annotation-config> does, plus it configures Spring to automatically discover beans and declare them for you without using <bean>.  
		- The base-package attribute tells <context:component-scan> the package to start its scan from.
	
	- By default, <context:component-scan> looks for classes that are annotated with one of a handful of special stereotype annotations:
		- Semantically the same: @Service and @Repository both extend @Component, but don't add any features
		- @Component : A general-purpose stereotype annotation indicating that the class is a Spring component. Regular components/beans,  any POJO.
		- @Controller : Indicates that the class defines a Spring MVC controller.
		- @Repository : Indicates that the class defines a data repository.
		- @Service : Indicates that the class defines a service.
		- Any custom annotation that is itself annotated with @Component

	- By default the bean’s ID will be generated by camel-casing the class name, alternatively someone can specify a bean ID as a parameter to @Component
	
	- Filtering component scans
		- By adding <context:include-filter> and/or <context:exclude-filter> subelements to <context:component-scan>
		- Component scanning can be customized using any of five kinds of filters
			- annotation - Filters scan classes looking for those annotated with a given annotation at the type level. The annotation to scan for is specified in the expression attribute
			- assignable - Filters scan classes looking for those that are assignable to the type specified in the expression attribute
			- aspectj - Filters scan classes looking for those that match the AspectJ type expression specified in the expression attribute
			- custom - Uses a custom implementation of org.springframework.core.type.TypeFilter, as specified in the expression attribute
			- regex - Filters scan classes looking for those whose class names match the regular expression specified in the expression attribute
		- For example,
			<context:component-scan base-package="com.springinaction.springidol">
				<context:include-filtertype="assignable" expression="com.abc.learning.Instrument"/>
				<context:exclude-filtertype="annotation" expression="com.abc.learning.SkipIt"/>
			</context:component-scan>
		

